# 面向灾难的服务器文件存储

# File Storage For Catastrophic



随着人们越来越多地使用电子设备，进行日常的学习与工作。这导致了人们将大量的重要资料，以电子文件的形式存储在个人计算机里。而个人计算机一旦丢失，这些资料往往难以找回，或者找到的文件并不完整。**本项目使用基于Rsync的同步算法，在个人服务器或中央服务器上备份个人电脑上的文件。以高频率，低带宽的形式进行文件的增量同步，即只同步原文件修改的部分。通过加密算法对传输数据进行加密，确保文件在同步过程中的安全性。做到用户能够方便地对已同步的文件，进行批量恢复，或是恢复单个文件的历史版本等功能。**消除文件仅保存在本地的不安全性。

### 系统架构

![image-20220901124851927](https://s2.loli.net/2022/09/01/5KOP1BaSpxrfeNI.png)

### Rsync实现

![image-20220901124918689](https://s2.loli.net/2022/09/01/pEnrb5K1ZhqygkN.png)

### 自定义协议

![image-20220901124947549](https://s2.loli.net/2022/09/01/JmUXgwltb6n9Eeq.png)

![image-20220901124955385](https://s2.loli.net/2022/09/01/KRdprWDn5j9Mkth.png)

通过自定义rpc协议减少传输协议携带不必要的数据

### 增量同步

采用的解决方案

1. Rsync算法
2. 本地更新了一个文件
3. 向服务器端发送文件同步请求
4. 服务器端响应确认收到请求，计算服务器端文件的哈希块列表，一起发送给本地端
5. 本地端将哈希块列表用哈希表储存
6. 将本地文件与哈希表做对比
7. 结果为BLOCK和DATA的结合体，储存在通道中，发送给服务器端
8. 服务器端使用通道结果进行文件复现，所发送的数据实际大小为，与所有BLOCK都不相似的数据。

![](https://s2.loli.net/2022/09/01/FfraGnWPdEZ5NvQ.png)

![image-20220901124521389](https://s2.loli.net/2022/09/01/egczvqyfbZPo256.png)

### Rpc部分

在TCP的字节流中，请求消息分为三部分：

- 由可变长量编码的 uint 类型用来标识请求头的长度；
- 基于自定义协议编码的请求头部信息
- 基于 Protocol Buffer 协议编码的请求体。

响应消息分为三部分：

- 由可变长量编码的 uint 类型用来标识响应头的长度；
- 基于自定义协议编码的响应头部信息
- 基于 Protocol Buffer 协议编码的响应体。

其中ID为RPC调用的序号，以便在并发调用时，客户端根据响应的ID序号来判断RPC的调用结果；

Error message为调用时发生错误的消息，若该内容为空则表示未出现RPC调用错误；

在请求I/O流中，请求体（Request Body）表示RPC的参数内容；而在响应I/O流中，响应体（Response Body）则表示RPC调用的结果，均采用 Protocol Buffer 协议编码。



### 参考：

https://github.com/juli4n/rsync

https://github.com/zehuamama/tinyrpc